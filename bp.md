ID-2
##Define domain scope 
Define the appropriate domain scope of your solution. The scope of a DSM solution should be closley alined with business needs.
ID-3
##Identify DSL usage 
The early identification of language usage will have strong influence on language concepts. Precisly identify and describe usage of a domain specific language. Usages of a DSL in real world production scenarios are an important source of knowledge to support decisions in language design and implementation. 
ID-135
##Use end-user personas  

ID-134
##Perform expert review 
description
ID-79
##Do not overestimate domain experts 
description
ID-4
##Understand present solution 
description
ID-6
##Balance genericity and specialization 
description
ID-5
##Reuse language definitions 
description
ID-7
##Adopt existing domain notations 
description
ID-9
##Support model reuse on language level 
description
ID-8
##Design must have purpose 
description
ID-16
##Design for language evolution 
description
ID-10
##Carefully choose form of notation 
description
ID-13
##Avoid redundancy 
description
ID-15
##Viewpoint orientation 
description
ID-28
##Provide Integrability 
description
ID-14
##Make elements distinquishable  
description
ID-22
##Consistent style everywhere 
description
ID-18
##Limit nr. of language elements 
description
ID-171
##Support variability on language level 
description
ID-11
##Reuse type systems 
description
ID-12
##Keep it simple 
description
ID-73
##Effective process for DSML definition 
description
ID-30
##Care for quality 
description
ID-136
##Perform Care for usability evaluations 
description
ID-172
##Create guidelines for language design 
description
ID-173
##Define language rules 
description
ID-165
##Derive concepts from physical sturcture 
description
ID-166
##Derive concepts from Look\&Feel 
description
ID-199
##First things first - the language 
description
ID-168
##Derive concepts from  domain 
description
ID-169
##Derive concepts from expected output 
description
ID-170
##Reuse existing computational model 
description
ID-21
##Balance compactness and understandability 
description
ID-23
##Interface concept 
description
ID-124
##Precise high-level abstraction 
description
ID-125
##Detect recurring patterns in design 
description
ID-17
##Compose existing languages 
description
ID-126
##Provide sufficient level of detail 
description
ID-127
##Multiple levels of abstractions 
description
ID-128
##Clear language to target mapping 
description
ID-25
##Turn API into DSL 
description
ID-26
##Strive for 80\% solution 
description
ID-29
##Care for longevity 
description
ID-31
##Care for scalabiltiy 
description
ID-32
##Care for usability 
description
ID-34
##Beware of misplaced emphasis 
description
ID-33
##A library is not the language 
description
ID-175
##Filter details from notational elements 
description
ID-177
##Use colors 
description
ID-178
##Use transparency containments 
description
ID-179
##Derive notation from corporate identity 
description
ID-180
##Ask graphic designers for help 
description
ID-19
##Use descriptive notations 
description
ID-20
##Usage of syntactic sugar 
description
ID-24
##Transform visual to text 
description
ID-27
##Use mixtuer of language notations 
description
ID-35
##Importance of meta-tooling 
description
ID-36
##Importance of DSL-tooling 
description
ID-186
##Use generators of varing granularity 
description
ID-72
##Incremental development 
description
ID-37
##Partition your meta-model 
description
ID-45
##Don't modify generated code 
description
ID-51
##Simplify generators 
description
ID-59
##Use source-source transformation 
description
ID-58
##Restrict host language by specialization 
description
ID-61
##DSL preprocessing  
description
ID-62
##System front-end DSL for configuration 
description
ID-63
##Pipeline DSL processors 
description
ID-204
##Provide meta-metamodel 
description
ID-131
##Use constraint language in Meta-modeling 
description
ID-198
##Create proof of concepts to show benefits 
description
ID-200
##Follow inhouse standards 
description
ID-55
##Document your code 
description
ID-78
##Plan DSL usage reviews 
description
ID-65
##Identify DSL usage process 
description
ID-195
##Move duplicated code to domain framework 
description
ID-196
##Provide good API for generated code 
description
ID-43
##Domain specific frameworks 
description
ID-64
##Hide complexity in domain framework 
description
ID-176
##Provide user modes  
description
ID-38
##Identify usage convention 
description
ID-41
##Teamwork support 
description
ID-44
##Check constraints first 
description
ID-68
##Avoid debugging at source-code-level 
description
ID-111
##Target-Specific Generator Classes 
description
ID-183
##Turn DSM models into documenation 
description
ID-184
##Integrate handwritten code on file level 
description
ID-185
##Use autobuild for DSM models 
description
ID-189
##Parallel generators per prog. langugage 
description
ID-191
##One version for all 
description
ID-193
##Do not build generator to soon 
description
ID-114
##Generate all documents 
description
ID-122
##Stabilize design quickly 
description
ID-119
##Modularize transformations 
description
ID-120
##Consistent input to transformations 
description
ID-42
##Interpretation vs. code generation 
description
ID-46
##Control manually written code 
description
ID-47
##Care about generated code 
description
ID-48
##Make code true to the model 
description
ID-49
##Viewpoint aware processing 
description
ID-50
##Care about templates 
description
ID-56
##Effective Generators 
description
ID-66
##Avoid semiautomatic transformation 
description
ID-82
##Mapping grammars to recursive-descent reco 
description
ID-90
##Normalized Heterogeneous AST 
description
ID-91
##Irregular Heterogeneous AST 
description
ID-92
##Embedded Heterogeneous Tree Walker 
description
ID-93
##External Tree Visitor 
description
ID-94
##Tree Grammar 
description
ID-95
##Tree Pattern Matcher 
description
ID-96
##Symbol Table for Monolithic Scope 
description
ID-97
##Symbol Table for Nested Scopes 
description
ID-98
##Symbol Table for Data Aggregates 
description
ID-99
##Symbol Table for Classes 
description
ID-83
##LL(1) Recursive-Descent Lexer 
description
ID-100
##Computing Static Expression Types 
description
ID-101
##Automatic Type Promotion 
description
ID-102
##Enforcing Static Type Safety 
description
ID-103
##Enforcing Polymorphic Type Safety 
description
ID-104
##Syntax-Directed Interpreter 
description
ID-105
##Tree-Based Interpreter 
description
ID-106
##Bytecode Assembler 
description
ID-107
##Stack-Based Bytecode Interpreter 
description
ID-108
##Register-Based Bytecode Interpreter 
description
ID-109
##Syntax-Directed Translator 
description
ID-84
##LL(1) Recursive-Descent Parser 
description
ID-110
##Rule-Based Translator 
description
ID-85
##Backtracking Parser 
description
ID-86
##Memoizing Parser 
description
ID-87
##Predicated Parser 
description
ID-88
##Parse Tree 
description
ID-89
##Homogeneous AST 
description
ID-205
##Reuse mechanisms in metamodel 
description
ID-206
##Model sharing and splitting mechanisms 
description
ID-207
##Version your models 
description
ID-112
##Use DSL to enforce standards 
description
ID-39
##Syntax alignment of concepts 
description
ID-145
##Sematic Model 
description
ID-154
##Regex Table Lexer 
description
ID-155
##Recursive Descent Parser 
description
ID-156
##Parser Combinator 
description
ID-157
##Parser Generator 
description
ID-158
##Tree Construction 
description
ID-159
##Parser Embedded Translation 
description
ID-160
##Parser Embedded Interpretation 
description
ID-161
##Foreign Code 
description
ID-162
##Alternative Tokenization 
description
ID-163
##Nested operator expression 
description
ID-146
##Symbol Table 
description
ID-164
##Newline Separators 
description
ID-147
##Context Variable 
description
ID-148
##Construction Builder 
description
ID-149
##Macro: Transform input text 
description
ID-150
##Notification for meta-model 
description
ID-151
##Delimiter-Directed Translation 
description
ID-152
##Syntax-Directed Translation 
description
ID-153
##Formally define the syntax of your languag 
description
ID-141
##Atomic concept pattern 
description
ID-142
##Entitype pattern 
description
ID-143
##Deep configuration pattern 
description
ID-144
##Concept tailoring pattern 
description
ID-52
##Allow for adaptation 
description
ID-53
##Create annotation models 
description
ID-54
##Test your DSL 
description
ID-57
##Base implementation on usage 
description
ID-60
##Data-structure representation 
description
ID-67
##Avoid enforcing validation rules 
description
ID-81
##Separate language model from validation 
description
ID-81
##Piggyback 
description
ID-40
##Syntax agnostic layouts  
description
ID-132
##Instance representation for meta-models 
description
ID-130
##Common graphical notation for meta-tooling 
description
ID-74
##Provide training 
description
ID-77
##Understand and deal with your weaknesses  
description
ID-80
##Users do not overlook your mistakes 
description
ID-182
##Use tooling for model evolution 
description
ID-201
##Plan for evolution 
description
ID-123
##Expect redesign and plan 
description
ID-71
##Domain engineering team 
description
ID-75
##Iterative development 
description
ID-197
##DSM requires organization 
description
ID-76
##Treat DSM as product development 
description
ID-69
##Aquire language development expertise 
description
ID-70
##Fit technology transfer to business model 
description
ID-138
##Define cost-benefit of generator testing 
description
ID-139
##Use fuzzy testing 
description
ID-140
##Measure test coverage 
description
ID-137
##Create DSLs for testing DSLs 
description
